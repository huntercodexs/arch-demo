
# ARCH DEMO
Sample to build a simple or complex system based on microservices architecture


# Project

- Language: <a href="README.md">Portugues Brazil (pt-br)</a>  |  English (en)
- Version: 1.0
- Date: 22/01/03


# Summary

- Resources
- Dependencies
- Extras
- Overview
- How it works
- More details
- Sequence Diagram
- Authorization Process
- Secure Environment
- How to use
- OpenAPI


# Resources

- Java Spring Boot
- Maven 2.3.6
- JDK-1.8 (jdk1.8.0_212)
- Mysql-5.7 / Mysql-8.0


# Dependencies

- OAuth2
- Eureka
- Zuul
- Zipkin
- Prometheus
- Elasticsearch
- Kibana
- Logback
- Swagger
- Lombok
- JPA Spring Data
- RabbitMQ


# Extras

- Docker
- Docker Compose
- Nginx


# Overview

> About

The objective of this project is to show how an environment with an architecture oriented to microservices works, where it is
possible to notice that this work philosophy makes the environment more organized, easy to understand and, finally, easy to
to maintain.

Microservices-oriented architecture is a market requirement that needs to quickly develop solutions with
guarantees, security, organization, scalability, flexibility, among others.

That is why it is important, first of all, to understand the concept well and then apply them in practice, guaranteeing a satisfactory
integration between development and maintenance.

During the explanations below the following terms will be used:

- check-service-status
  - this procedure is internal to SERVICE-ROUTER and has the function of checking if a service is OK
- request-token
  - initial procedure so that an operator can generate an OAuth2 token and have an authorization to consume services
- request-service
  - procedure used when the operator wants to consume any service (example: SERVICE-DEMO)
- check token
  - internal and automatic procedure that the SERVICE-ROUTER service executes to validate an operation via OAuth2
- access-token
  - random token generated by SERVICE-AUTHORIZATOR that must be used for validation in transactions

> Details

Some graphic models, diagrams and flowcharts were developed to illustrate in many ways how the environment
arch-demo works. The sequence diagram is the most specific to verify the technical and direct functioning of the
flows present in this architecture, an example would be the get-token flow for authorization and authentication.

The graphic templates are as follows:

- Complete Flow
- Details
- Compact
- Request Token
- Request Service
- Check Token
- Data Relation
- Sequence
- Sequence (Nginx)
- Sequence Service Status (Router Details)

All these diagrams will be detailed and explained below.


# How it works

The "Complete Flow" schematic diagram shows how request-token, check-token and
request-service, being addressed the entire flow and lifetime of the request, notice that there is an internal flow to the
SERVICE-ROUTER that checks if a service is OK (check-service-status).

The request is made by any REQUESTER, for example using POSTMAN, reaching the SERVICE-ROUTER which is the gateway
of the environment and which has knowledge of all the microservices contained in the environment. All services are
accessed through this SERVICE-ROUTER (API-GATEWAY) which, when capturing a request by any route, accesses the resource
target through information obtained from the SERVICE-DISCOVERY (EUREKA) service where all services in the environment
are duly authenticated and registered.

The SERVICE-ROUTER microservice checks the request, if it is a request-token request, it just forwards
the same for the SERVICE-AUTHORIZATOR service. If it is a request-service request, it automatically performs a
call to itself of type check-token to guarantee the security of the transaction, that is, before executing a
request-service you need to run a request-token.

>> An important point in this flow is the automatic procedure that SERVICE-ROUTER does defined as
> check-service-status to validate if the service is available, this procedure can be skipped with a simple
> configuration in the SERVICE-ROUTER application.properties file.

> Complete Flow

![img.png](midias/Complete-Flow.png)

In the case of requests of the request-service and check-token type, it is mandatory that the REQUESTER inform the code of
access to the SERVICE-ROUTER referring to the CLIENT/MICROSERVICE that you want to consume, ex SERVICE-DEMO (Address) identified by
access code "XYZ-123", so that the SERVICE-ROUTER can obtain the basic authorization of the CLIENT/MICROSERVICE, being that
the check-token type request is automatically made by the SERVICE-ROUTER.

The request-token request must be aligned with the check-token request, that is, the data for authorization of
CLIENT/MICROSERVICE usage needs to be correct as shown in the image below:

> Data Relation

![img.png](midias/Data-Relation.png)

See that the REQUESTER (Operator) is using data for authorization from a CLIENT/MICROSERVICE named arch_demo_client_1
followed by your secret-key 11111111-2222-3333-4444-555555555555, which form the final STRING for authorization
in SERVICE-AUTHORIZATOR, this STRING being used as BASIC-AUTH as shown below:

<pre>
Data-Client[username]: arch_demo_client_1
Data-Client[password]: 11111111-2222-3333-4444-555555555555
Basic-Auth[base64]: YXJjaF9kZW1vX2NsaWVudF8xOjExMTExMTExLTIyMjItMzMzMy00NDQ0LTU1NTU1NTU1NTU1NQ==
</pre>

<pre>
Request-Header[Authorization]: Basic YXJjaF9kZW1vX2NsaWVudF8xOjExMTExMTExLTIyMjItMzMzMy00NDQ0LTU1NTU1NTU1NTU1NQ==
Request-Body[grant_type]: password
Request-Body[username]: OAUTH2DEMO_USER
Request-Body[password]: 1234567890
</pre>

This generates a token in the SERVICE-AUTHORIZATOR for the REQUESTER to consume the identified CLIENT/MICROSERVICE
in Request-Header[Authorization] above.

In the next requests, it will be necessary to send the token generated for this CLIENT/MICROSERVICE with the access code of the
SERVICE-ROUTER, which in this case is XYZ-123 referring to the CLIENT/MICROSERVICE in the environment, as follows:

<pre>
Access-Code: XYZ-123
</pre>

<pre>
Basic-Auth[base64]: YXJjaF9kZW1vX2NsaWVudF8xOjExMTExMTExLTIyMjItMzMzMy00NDQ0LTU1NTU1NTU1NTU1NQ==
</pre>

<pre>
Request-Header[Authorization]: Basic YXJjaF9kZW1vX2NsaWVudF8xOjExMTExMTExLTIyMjItMzMzMy00NDQ0LTU1NTU1NTU1NTU1NQ==
Request-Body[access-token]: bcb88919-562f-4564-9976-afc8672b613b
</pre>

The entire authorization and authentication process is done through the SERVICE-ROUTER integrated into the SERVICE-AUTHORIZATOR, see
that at the end of this process we have a request of the request-service type that calls a SERVICE-DEMO service passing the
following parameters:

<pre>
Request-Header[Access-Code]: XYZ-123
Request-Header[Authorization]: Bearer bcb88919-562f-4564-9976-afc8672b613b
Request-Body[JSON]: {"rulesCode": "XYZ12345","postalCode": "12090002","webhook": ""}
</pre>

As mentioned above, the Access-Code is used to obtain the BASIC-AUTH authorization from the CLIENT/MICROSERVICE which together with the
access-token contained in "Request-Header[Authorization]: Bearer bcb88919-562f-4564-9976-afc8672b613b" makes it possible
validate the transaction referring to the current request.

Still in this flow, right after the authorization and authentication process, there is a service called SERVICE-RULES that
is in charge of validating rules for using the environment and the services available in it, reducing the risk of use
inappropriate. This service manages the environment considering the settings and permissions of each
service in the environment, that is, it is who says if an application, example SERVICE-DEMO, can continue and be executed in the
platform, and if it is correctly configured. All the configuration of this service is done in the database and accessed
through JPA to then be processed within the SERVICE-RULES according to the duly applied rules.


# More details

Next, a deeper detailing of the environment, having a broader view of how the
services and operations, which are the entities (models) of each service and a symbolic representation of the database.
It is possible to see that each service is separated by its specific function and has its own database, as well as
external or adjacent resources pertaining to a single unit of work.

> Details

![img.png](midias/Details.png)

Without much detail, the flowchart below shows in a very compact and direct way the complete flow of operations performed in the
environment oriented to microservices ARCH-DEMO, ARCH-PRO or even CODEXS-ARCH.

> Compact

![img.png](midias/Compact.png)

> Router Details

The sequence diagram below illustrates how the REST request router service works in order to verify that the services
are actually available even before forwarding the request to its destination. The Check Service Status step is
automatically executed in the SERVICE-ROUTER when a request arrives at it, being easy to understand or
understanding its operation through analysis of the source code.

![img.png](midias/Sequence-Diragram-Router-Details.png)

This "service status" check needs to be added to all microservices that are part of the
platform work, in this case ARCH-DEMO or ARCH-PRO or CODEXS-ARCH. This procedure is done including
in each microservice a controller to receive and respond to REST requests duly authorized through the
basic authentication "BASIC AUTH".

To configure a new service in the environment, follow the instructions below:

- Create a new "package", example "archdemo", inside an existing "package", example "config", as illustrated below:

![img.png](midias/Service-Status.png)

- Create the files AliveController.java and AliveService.java inside the "package" created previously, see the examples
  below to create these files:

> NOTE: Do not change the logic of the files, just configure the routes and data to be used

AliveController.java
<pre>
 1 package com.huntercodexs.archdemo.demo.config.archdemo;
 2
 3 import lombok.extern.slf4j.Slf4j;
 4 import org.springframework.beans.factory.annotation.Autowired;
 5 import org.springframework.web.bind.annotation.*;
 6
 7 import javax.servlet.http.HttpServletRequest;
 8
 9 @Slf4j
10 @RestController
11 @CrossOrigin(origins = "*")
12 @RequestMapping("${api.prefix}")
13 public class AliveController {
14
15 @Autowired
16 AliveService aliveService;
17
18 @GetMapping(path = "/address/arch-demo-status")
19 @ResponseBody
20 public String alive(HttpServletRequest request) {
21 return aliveService.alive(request);
22 }
23
24 }
</pre>

In line 18 of the code above use the following configuration for correct operation:
/${service-endpoint}/arch-demo-status, as this endpoint will be called by SERVICE-ROUTER during a REST request,
For example, the request below:

<pre>
http://localhost:33001/huntercodexs/arch-demo/service-demo/api/address
</pre>

expects to have in the service called "Address" the following endpoint

<pre>
http://localhost:33001/huntercodexs/arch-demo/service-demo/api/address/arch-demo-status
</pre>

AliveService.java
<pre>
 1 package com.huntercodexs.archdemo.demo.config.archdemo;
 2
 3 import lombok.extern.slf4j.Slf4j;
 4 import org.springframework.beans.factory.annotation.Value;
 5 import org.springframework.stereotype.Service;
 6
 7 import javax.servlet.http.HttpServletRequest;
 8 import java.util.Base64;
 9
10 @Slf4j
11 @Service
12 public class AliveService {
13
14 @Value("${eureka.security.login}")
15 String basicAuthService;
16
17 public String alive(HttpServletRequest request) {
18 String basicAuthRequest = new String(Base64.getDecoder().decode(
19 request.getHeader("Authorization").replaceFirst("Basic ", "")));
20 if (basicAuthRequest.equals(basicAuthService)) {
21 return "alive";
22 }
23 return null;
24 }
25
26 }
</pre>

In the code above, you only need to pay attention to line 14, where the value to perform authentication of type is set
"BASIC AUTH", for example:

<pre>
eureka.security.login=arch-demo:1234567890-1111-2222-3411111-000001
</pre>

> NOTE: This value is the same used to register the application or microservice in SERVICE-DISCOVERY (Eureka), by
> it doesn't change it in any way, it should be configured in the application.properties file

That way, whenever SERVICE-ROUTER receives a request to route, it will first check if the service
is available through a REST call, sending the value of "eureka.security.login" in the request HEADER to
perform basic authentication: Basic YXJjaC1kZW1vOjEyMzQ1Njc4OTAtMTExMS0yMjIyLTM0MTExMTEtMDAwMDAx.

# Sequence Diagram

The sequence diagram below shows a complete request flow made by REQUESTER with the intention of consuming the
service called DEMO (SERVICE-DEMO). Note that the whole flow starts after the request request-token is started,
which is forwarded by the ROUTER (SERVICE-ROUTER) to the AUTHORIZATOR service (SERVICE-AUTHORIZATOR) for token generation.

There are two requests: request-token and request-service made by the REQUESTER, however the REQUESTER (operator) has to be
previously registered in the AUTHORIZATOR service (SERVICE-AUTHORIZATOR). The ROUTER (SERVICE-ROUTER) manages all
calls, in this case still without using a WEBSERVER with REVERSE-PROXY, and as soon as all operations are finished
a response is sent to the REQUESTER for viewing.

> Sequence

![img.png](midias/Sequence.png)


# Authorization Process

Below is a complete flow for a request of the request-token type, where it is possible to observe what has already been
previously said about the data that must be sent to authorize, authenticate and generate a token for a REQUESTER
any. See that we have the CLIENT/MICROSERVICE data informed in the HEADER of the request with the BASIC-AUTH format,
as well as the credentials of the operator, which in this case is a user called OAUTH2DEMO_USER, also notice that it is informed
the GRANT-TYPE that the AUTHORIZATOR service (SERVICE-AUTHORIZATOR) expects, in this case "password".

The ROUTER service (SERVICE-ROUTER) receives the request and forwards it to the AUTHORIZATOR service (SERVICE-AUTHORIZATOR) which
when completing the authentication operations, it generates an access-token and response to the ROUTER (SERVICE-ROUTER) to be returned
to REQUESTER. From that point on, the REQUESTER must save the access-token and inform it in future requests.

***In this case, there is no access control header identified as: Access-Token***

> Request Token Flow

![img.png](midias/Request-Token.png)

The following flow called request-service inevitably depends on the previous flow request-token, as you need to generate the
access-token and use it in this step. See that in the flow there is a block illustrating a request of this type simulating a
real operation, where we can notice the existence of the token in the HEADER of the request. Still at this point we have another HEADER
called Access-Code which is used to obtain the STRING BASIC-AUTH of CLIENT/MICROSERVICE authorization, this process
it is done internally by the ROUTER (SERVICE-ROUTER), as it is necessary to know who was authorized to perform an operation.

Continuing in this request-service process, we have the internal and automatic request called check-token activated
by the ROUTER (SERVICE-ROUTER) whenever it receives a request of type request-service. This step of the operation takes place
in the backend of the environment, and when everything goes well, the ROUTER service (SERVICE-ROUTER) forwards the request request-service
to your original destination.

Right after the "test by fire" or the "challenge" of authorization and authentication, the request arrives at the DEMO service
(SERVICE-DEMO) which makes a call to RULES (SERVICE-RULES), which validates if the Rules-Code and Service-Id are
correct, and it is very clear rules to consume this service, which are specific and inherent to the environment where the
services are running.

> NOTE: SERVICE-RULES is a microservice with the responsibility to ensure that microservices are correctly
> configured and allowed within a restricted processing environment.

> Request Service Flow

![img.png](midias/Request-Service.png)

The previously generated token verification step is contained in the request-service request and already
was discussed earlier in this content. Therefore, it does not need many explanations about the scopes already mentioned,
however in the image below we can notice a novelty in the AUTHORIZATOR service block (SERVICE-AUTHORIZATOR), we see that
the token generated in the previous steps is being kept in memory on the machine that is running SERVICE-AUTHORIZATOR,
and this is how OAuth2 checks the token sent in the check-token request. Of course, this is a procedure
internal to OAuth2 and this is not the place to explain the operations performed in this scope of the process.

> Check Token Flow

![img.png](midias/Check-Token.png)


# Secure Environment

The environment below shows an environment that is more restricted to external access, previously we had an open structure
of microservices running independently, but with exposure of its members to external agents, making
insecure platform.

With the infrastructure proposal shown in the following figure, a WEBSERVER was inserted to orchestrate the requests
external services in such a way that the entire service platform from the ROUTER (SERVICE-ROUTER) to any service, for example,
DEMO (SERVICE-DEMO) are protected from unauthorized access, as the IP and port where they are running are private.

The request is made by the REQUESTER (operator) which reaches its final objective going through the same steps discussed
in this document, but with the implementation of NGINX that works in reverse with requests forwarding and
translating the requests into the secure environment.

Note that there is an internal network limited by subnet 10.0.0.0/16 where its members can communicate, but not
can be accessed from outside this network if not through NGINX. Also note that it is possible to customize the input url
in NGINX to the ROUTER (SERVICE-ROUTER), for example:

- NGINX
<pre>
Request Token
http://localhost:33001/nginx/huntercodexs/arch-demo/service-authorizator/api/rest/oauth/v1/oauth/token
</pre>

- ROUTER
<pre>
Reverse Proxy
http://10.0.0.2:33400/huntercodexs/arch-demo/service-authorizator/api/rest/oauth/v1/oauth/token
</pre>

This allows hiding both the real endpoint of the microservices as well as the port on which it is running.

> NOTE: To offer even more security, you can use your own domain with a secure communication protocol,
> for example: http://api.domain.com/nginx/huntercodexs/arch-demo/service-authorizator/api/rest/oauth/v1/oauth/token

> Using Nginx Webserver

![img.png](midias/Secure-Environment.png)


# How to use

To use this project as a base for other projects and development, even if only for tests or studies, it is
as initiator of an environment, either for tests, or for presentations of academic or school work or for
any other purpose in the field of software development, follow the instructions below:

- Clone the project on a local machine:

<pre>
git clone https://github.com/huntercodexs/arch-demo.git
</pre>

See that a folder called arch-demo was created, containing the projects of that environment, media and documents, as well
as the POSTMAN file for testing.

In the arch-demo/microservices folder are the example services: SERVICE-DISCOVERY, SERVICE-ROUTER, SERVICE-RULES,
SERVICE-AUTHORIZATOR and SERVICE-DEMO. All of them are just to exemplify the environment and can be executed
immediately after loading the project into an IDEA (example: IntelliJ).

***It will still be necessary to configure the project to run in the secure environment using docker containers***

The image below illustrates the microservices registered in SERVICE-DISCOVERY (EUREKA) which are available
to be accessed through the SERVICE-ROUTER.

![img.png](midias/service-discovery-sample.png)

Another important point is the dedicated database for each service, not having connections between them, which could
cause confusion since we are talking about microservices.

The figure below shows an image of this scenario:

![img.png](midias/arch-demo-databases.png)

> SERVICE-DISCOVERY

This service is responsible for information from other services regarding state, address (IP), port, and so on.
resources, data that will be informed to the SERVICE-ROUTER when necessary.

> SERVICE-ROUTER

Service responsible for routing all requests made to the ARCH-DEMO environment, this service verifies with the service
SERVICE-DISCOVERY where is the target service to forward the request, either to request a token, or to validate
a token, either to check if a service is available or to consume some resource on the platform.

> SERVICE-AUTHORIZER

Service responsible for generating and validating OAuth2 tokens.

> SERVICE-RULES

In this service are the business rules of the environment, every microservice must be aligned with the rules imposed by
this member.

> SERVICE-DEMO

Example service to query addresses via Post Office with any zip code, can also be called DEMO, Address or Postal Code.

# OpenAPI (Swagger)

The documentation of an API is a very important point in a project, offering quality, maintenance, understanding and
support for developers of both the API itself and those developers who will consume the API. That's why I use
of this concept will be applied here in this project making use of Swagger which is a framework for documenting APIs,
also known as OpenAPI.

To document an API that is inside a microservice in the ARCH-DEMO environment, follow the instructions below:

- Add the dependency on the service that needs to be documented (example: SERVICE-DEMO):

<pre>
      &lt;dependency&gt;
          &lt;groupId>org.springdoc&lt;/groupId&gt;
          &lt;artifactId>springdoc-openapi-ui&lt;/artifactId&gt;
          &lt;version>1.6.4&lt;/version&gt;
      &lt;/dependency&gt;
</pre>

- Make the API documentation, to exemplify see the examples below:

> Controller or RestController

<pre>
package com.huntercodexs.archdemo.demo.controller;

import com.huntercodexs.archdemo.demo.config.codexsresponser.dto.CodexsResponserDto;
import com.huntercodexs.archdemo.demo.dto.AddressRequestDto;
import com.huntercodexs.archdemo.demo.dto.AddressResponseDto;
import com.huntercodexs.archdemo.demo.service.AddressService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;

@Slf4j
@RestController
@CrossOrigin(origins = "*")
@RequestMapping("${api.prefix}")
@Tag(name = "Address Service")
public class AddressController {

    @Autowired
    AddressService addressService;

    @Operation(
            summary = "Find Address",
            description = "Microservice to get an address from anyone postal code"
    )
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Address found successfull", content = {
                    @Content(mediaType = "application/json", schema = @Schema(implementation = AddressResponseDto.class))
            }),
            @ApiResponse(responseCode = "400", description = "Invalid request", content = {
                    @Content(mediaType = "application/json", schema = @Schema(implementation = CodexsResponserDto.class))
            }),
            @ApiResponse(responseCode = "401", description = "Access denied", content = {
                    @Content(mediaType = "application/json", schema = @Schema(implementation = CodexsResponserDto.class))
            }),
            @ApiResponse(responseCode = "404", description = "Address not found", content = {
                    @Content(mediaType = "application/json", schema = @Schema(implementation = CodexsResponserDto.class))
            }),
            @ApiResponse(responseCode = "406", description = "Not accceptable", content = {
                    @Content(mediaType = "application/json", schema = @Schema(implementation = CodexsResponserDto.class))
            }),
            @ApiResponse(responseCode = "500", description = "Internal error", content = {
                    @Content(mediaType = "application/json", schema = @Schema(implementation = CodexsResponserDto.class))
            })
    })
    @PostMapping(path = "/address", produces = MediaType.APPLICATION_JSON_VALUE)
    @ResponseBody
    public ResponseEntity&lt;AddressResponseDto&gt; getAddress(
            @Valid @RequestBody(required = true) AddressRequestDto addressRequestDto
    ) {
        return addressService.getAddress(addressRequestDto);
    }

}
</pre>

> Error Response DTO

<pre>
package com.huntercodexs.archdemo.demo.config.codexsresponser.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Schema(description = "This object refers to Codexs Responser Handler", name = "Codexs Responser")
public class CodexsResponserDto {

    @Schema(
            description = "Runtime code error or excetion defined in the application.",
            example = "9000",
            required = true)
    public int errorCode;

    @Schema(
            description = "Message refer to errorCode defined in the application.",
            example = "Address not found",
            required = true)
    public String message;
}
</pre>

> Request DTO

<pre>
package com.huntercodexs.archdemo.demo.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.*;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.NotNull;

@Getter
@Setter
@ToString
@NoArgsConstructor
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Schema(description = "This object refers to Address Request", name = "Address Request")
public class AddressRequestDto {

    @Schema(
            description = "Rules code to access rules server according with the rules defined.",
            example = "XYZ-123",
            required = true)
    @NotNull @NotEmpty @NotBlank
    String rulesCode;

    @Schema(
            description = "Postal code number (only numbers).",
            example = "12090002",
            required = true)
    @NotNull @NotEmpty @NotBlank
    String postalCode;

    @Schema(
            description = "Webhook callback.",
            example = "http://api.sample.com/receptor",
            required = false)
    String webhook;
}
</pre>

> Response DTO

<pre>
package com.huntercodexs.archdemo.demo.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.*;

@Getter
@Setter
@ToString
@NoArgsConstructor
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Schema(description = "This object refers to Address Response", name = "Address Response")
public class AddressResponseDto {

    @Schema(
            description = "Postal number refer to query.",
            example = "12090002",
            required = true)
    public String cep;

    @Schema(
            description = "Name of the place found",
            example = "R Alameda Santos",
            required = true)
    public String logradouro;

    @Schema(
            description = "Addtional information about address found.",
            example = "Ao lado do shopping BigHouse",
            required = true)
    public String complemento;

    @Schema(
            description = "District name.",
            example = "Campo Belo",
            required = true)
    public String bairro;

    @Schema(
            description = "City or downtown.",
            example = "Sao Paulo",
            required = true)
    public String localidade;

    @Schema(
            description = "State Acronym.",
            example = "PR",
            required = true)
    public String uf;

    @Schema(
            description = "Others information about address (ibge).",
            example = "12345",
            required = false)
    public String ibge;

    @Schema(
            description = "Username of the user to be create (email or cpf).",
            example = "12345",
            required = false)
    public String gia;

    @Schema(
            description = "Phone Digit Code to address found (ddd).",
            example = "88888888888",
            required = false)
    public String ddd;

    @Schema(
            description = "Others information about address (siafi).",
            example = "12345",
            required = false)
    public String siafi;
}
</pre>

> NOTE: If you want to hide a controller in the documentation, use @Hidden as shown below:

<pre>
package com.huntercodexs.archdemo.demo.config.archdemo;

import io.swagger.v3.oas.annotations.Hidden;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;

@Slf4j
@RestController
@CrossOrigin(origins = "*")
@RequestMapping("${api.prefix}")
@Hidden
public class AliveController {

    @Autowired
    AliveService aliveService;

    @GetMapping(path = "/address/arch-demo-status")
    @ResponseBody
    public String alive(HttpServletRequest request) {
        return aliveService.alive(request);
    }

}
</pre>

> Configure the SERVICE-DEMO application.properties file as suggested below:

<pre>
# SWAGGER
#-------------------------------------------------------------------------------------------------------------------
# See more: https://springdoc.org/properties.html
#true, false
springdoc.swagger-ui.enabled=true
#Application path
springdoc.swagger-ui.path=/huntercodexs/arch-demo/service-demo/swagger-ui
#Ordered
springdoc.swagger-ui.operationsSorter=method
#StandaloneLayout, BaseLayout
springdoc.swagger-ui.layout=StandaloneLayout
#/api-docs, api-docs-guard, /api-docs-custom
springdoc.api-docs.path=/api-docs/service-demo
#true, false
springdoc.model-and-view-allowed=true
</pre>

***An important point is to pay attention to the configuration of springdoc.api-docs.path=/api-docs/service-demo, because it should
be aligned with the route configuration in SERVICE-ROUTER as shown further below***

After performing all the adjustments mentioned above, and also the API documentation, check if you can access the
swagger by the uri defined in springdoc.swagger-ui.path, as in the example below:

<pre>
http://localhost:41233/huntercodexs/arch-demo/service-demo/swagger-ui/index.html
</pre>

For this, it is necessary to correctly inform which port the microservice is running on, in this case 41233.
accessing the page, you will be able to view a screen as shown below:

![img.png](midias/OpenAPI-Swagger.png)

- Tune the SERVICE-ROUTER to meet the security requirements of the environment

Until now, it was only possible to access Swagger through the direct link and having the knowledge of where the service is being
executed, however, it will be necessary to adjust the SERVICE-ROUTER to understand these OpenAPI requests and direct them to the correct route.

> Add the following configuration in the SERVICE-ROUTER application.properties file

<pre>
zuul.routes.service-demo-swagger.path=/api-docs/service-demo/**
zuul.routes.service-demo-swagger.service-id=SERVICE-DEMO
zuul.routes.service-demo-swagger.strip-prefix=false
zuul.routes.service-demo-swagger.sensitive-headers=
</pre>

Look that there is a new entry referring to SERVICE-DEMO, but now it refers to the OpenAPI resource contained in the
microservice SERVICE-DEMO configured in line zuul.routes.service-demo-swagger.path=/api-docs/service-demo/**

***Note that the line zuul.routes.service-demo-swagger.path=/api-docs/service-demo refers to the path configured on the micro
SERVICE-DEMO service shown previously***

After making the changes in the SERVICE-ROUTER, access the Swagger of the SERVICE-DEMO microservice through the url

<pre>
http://localhost:33001/huntercodexs/arch-demo/service-demo/swagger-ui/index.html
</pre>

> NOTE. In the secure environment, the internal routes are not available to the public, as well as the ports where the computers
> services are running.
