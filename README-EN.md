
# ARCH DEMO
Sample to build a simple or complex system based on microservices architecture


# Project

- Language: <a href="README.md">Portugues Brazil (pt-br)</a>  |  English (en)
- Version: 1.0
- Date: 22/01/03


# Summary

- Resources
- Dependencies
- Extras
- Updates
- Overview
- How it works
- More details
- Sequence Diagram
- Authorization Process
- Secure Environment
- How to use
- TODO


# Resources

- Java Spring Boot
- Maven 2.3.6
- JDK-1.8 (jdk1.8.0_212)
- Mysql-5.7 / Mysql-8.0


# Dependencies

- OAuth2
- Eureka
- Zuul
- Zipkin
- Prometheus
- Elasticsearch
- Kibana
- Logback
- Swagger
- Lombok
- JPA Spring Data
- RabbitMQ


# Extras

- Docker
- Docker Compose
- Nginx


# Updates


# Overview

> About

This project was created with the intention of showing how a microservices-oriented environment works, in addition to more
organized and easy to understand and ultimately easier to maintain. Microservices-oriented architecture is a
current market demand that needs to quickly develop solutions with agility, guarantees, flexibility,
security, organization, scalability, among others.

That is why it is important first of all to understand the concept well and then apply its benefits in practice, ensuring
the perfect integration between development and maintenance.

During the explanations below, the following terms will be used:

- request-token
  - initial procedure so that an operator can generate an OAuth2 token and have an authorization to consume services
- request-service
  - procedure used when the operator wants to consume any service (DEMO)
- check-token
  - internal and automatic procedure that the ROUTER service executes to validate an operation via OAuth2
- access-token
  - random token generated by the AUTHORIZATOR and that must be used for validation in transactions

> Details

Several graphic resources (diagrams and flowcharts) were developed to illustrate in many ways how the environment
arch-demo works. The sequence diagram is the most specific to verify the technical and direct operation of the
flows present in the architecture, for example the get-token flow for authorization and authentication.

In total, there will be 9 diagrams, namely:

- Complete Flow
- Details
- Compact
- Request Token
- Request Service
- Check Token
- Data Relation
- Sequence
- Sequence (Nginx)

All these diagrams will be detailed and explained below.


# How it works

This schematic diagram shows how requests for request-token, check-token and
request-service, covering the entire flow and lifetime of the request.

The request is made by any REQUESTER, it can be the POSTMAN as an example, reaching the ROUTER which is the gateway
of the environment and which has the knowledge of all the micro services contained in the environment. All services are
accessed through the ROUTER (api-gateway) that, when capturing a request through any route, accesses the resource
target through information obtained from the DISCOVERY service which is nothing more than a SERVICE-DISCOVERY (Eureka) where
all environment services are registered.

The ROUTER microservice checks the type of request and if it is a request-token request, it just forwards it
the same for the AUTHORIZATOR service. If it is a request-service type request, it automatically performs a
call to itself of check-token type to ensure transaction security, i.e. before executing a
request-service you need to run a request-token.

> Complete Flow

![img.png](midias/Complete-Flow.png)

In the case of requests of the request-service and check-token type, it is mandatory for the REQUESTER to inform the
access to the ROUTER referring to the CLIENT you want to consume, in this case a micro service called DEMO, so that the
ROUTER can obtain authorization from the CLIENT, and the check-token type request is automatic and internal to the ROUTER.
The request-token request has to be aligned with the check-token request, that is, the data for authorization of
CLIENT usage has to be in accordance, as shown in the image below:

> Data Relation

![img.png](midias/Data-Relation.png)

See that the REQUESTER (Operator) is using the data for authorization of a CLIENT called by arch_demo_client_1
followed by its secret-key 11111111-2222-3333-4444-555555555555, which form the final STRING for authorization
in the AUTHORIZATOR, this STRING being used as BASIC-AUTH as shown below:

<pre>
>> Data-Client: arch_demo_client_1:11111111-2222-3333-4444-555555555555
<< Basic-Auth: YXJjaF9kZW1vX2NsaWVudF8xOjExMTExMTExLTIyMjItMzMzMy00NDQ0LTU1NTU1NTU1NTU1NQ==
</pre>

<pre>
Request-Header[Authorization]: Basic YXJjaF9kZW1vX2NsaWVudF8xOjExMTExMTExLTIyMjItMzMzMy00NDQ0LTU1NTU1NTU1NTU1NQ==
Request-Body[grant_type]: password
Request-Body[username]: OAUTH2DEMO_USER
Request-Body[password]: 1234567890 
</pre>

This causes a token to be generated in the AUTHORIZATOR for the CLIENT identified by BASIC-AUTH above, and in the next
requests, it will be necessary to send the generated token to this CLIENT along with the ROUTER access key, which
in this case it is XYZ-123 and refers to the CLIENT authorization in the environment, as follows:

<pre>
>> Access-Code: XYZ-123
<< Basic-Auth: YXJjaF9kZW1vX2NsaWVudF8xOjExMTExMTExLTIyMjItMzMzMy00NDQ0LTU1NTU1NTU1NTU1NQ==
</pre>

<pre>
Request-Header[Authorization]: Basic YXJjaF9kZW1vX2NsaWVudF8xOjExMTExMTExLTIyMjItMzMzMy00NDQ0LTU1NTU1NTU1NTU1NQ==
Request-Body[access-token]: bcb88919-562f-4564-9976-afc8672b613b
</pre>

The entire authorization and authentication process is done through the ROUTER integrated into the AUTHORIZATOR, see that at the end
from this process we have a request of the request-service type that calls a DEMO service passing the following parameters:

<pre>
Request-Header[Access-Code]: XYZ-123
Request-Header[Authorization]: Bearer bcb88919-562f-4564-9976-afc8672b613b
Request-Body[JSON]: {"rulesCode": "XYZ12345","postalCode": "12090002","webhook": ""}
</pre>

As mentioned above, Access-Code is used to get BASIC-AUTH authorization from client to along with token
of type Bearer to validate the transaction referring to the current request.

Still in this flow we can notice that after authorization and authentication there is a service called RULES which performs the
manages the environment taking into account the settings and permissions of each service in the environment, that is,
he is the one who says if the DEMO service can proceed and if it is correctly configured. All configuration of this service
is done in the database and accessed through JPA to then be processed within RULES according to the rules
properly applied.


# More details

Below we have a deeper detailing of the environment, having a broader view of how the
services and operations, which are the entities (models) of each service and a symbolic representation of the database.
We can see that each service is separated by its specific function and has its own database, as well as
external or adjacent resources pertaining to a single unit of work.

> Details

![img.png](midias/Details.png)

Without much detail, the flowchart below shows in a very compact and direct way the complete flow of operations within
of the ARCH-DEMO micro-services oriented environment.

> Compact

![img.png](midias/Compact.png)

> Router Details

The sequence diagram below illustrates how the REST request router service works in order to verify that the services
are actually available even before forwarding the request to its destination. The Check Service Status step is
automatically executed in the SERVICE-ROUTER when a request arrives at it, being easy to understand or
understanding its operation through analysis of the source code.

![img.png](midias/Sequence-Diragram-Router-Details.png)

This "service status" check needs to be added to all micro services that are part of the environment.
platform work, in this case ARCH-DEMO or ARCH-PRO or CODEXS-ARCH. This procedure is done including
in each microservice a controller to receive and respond to REST requests duly authorized through the
basic authentication "BASIC AUTH".

To configure a new service in the environment, follow the instructions below:

- Create a new "package", example "archdemo", inside an existing "package", example "config", as illustrated below:

![img.png](media/Service-Status.png)

- Create the files AliveController.java and AliveService.java inside the "package" created previously, see the examples
  below to create these files:

> NOTE: Do not change the logic of the files, just configure the routes and data to be used

AliveController.java
<pre>
 1 package com.huntercodexs.archdemo.demo.config.archdemo;
 2
 3 import lombok.extern.slf4j.Slf4j;
 4 import org.springframework.beans.factory.annotation.Autowired;
 5 import org.springframework.web.bind.annotation.*;
 6
 7 import javax.servlet.http.HttpServletRequest;
 8
 9 @Slf4j
10 @RestController
11 @CrossOrigin(origins = "*")
12 @RequestMapping("${api.prefix}")
13 public class AliveController {
14
15 @Autowired
16 AliveService aliveService;
17
18 @GetMapping(path = "/address/arch-demo-status")
19 @ResponseBody
20 public String alive(HttpServletRequest request) {
21 return aliveService.alive(request);
22 }
23
24 }
</pre>

In line 18 of the code above use the following configuration for correct operation:
/${service-endpoint}/arch-demo-status, as this endpoint will be called by SERVICE-ROUTER during a REST request,
For example, the request below:

<pre>
http://localhost:33001/huntercodexs/arch-demo/service-demo/api/address
</pre>

expects to have in the service called "Address" the following endpoint

<pre>
http://localhost:33001/huntercodexs/arch-demo/service-demo/api/address/arch-demo/status
</pre>

AliveService.java
<pre>
 1 package com.huntercodexs.archdemo.demo.config.archdemo;
 2
 3 import lombok.extern.slf4j.Slf4j;
 4 import org.springframework.beans.factory.annotation.Value;
 5 import org.springframework.stereotype.Service;
 6
 7 import javax.servlet.http.HttpServletRequest;
 8 import java.util.Base64;
 9
10 @Slf4j
11 @Service
12 public class AliveService {
13
14 @Value("${eureka.security.login}")
15 String basicAuthService;
16
17 public String alive(HttpServletRequest request) {
18 String basicAuthRequest = new String(Base64.getDecoder().decode(
19 request.getHeader("Authorization").replaceFirst("Basic ", "")));
20 if (basicAuthRequest.equals(basicAuthService)) {
21 return "alive";
22 }
23 return null;
24 }
25
26 }
</pre>

In the code above, you only need to pay attention to line 14, where the value to perform authentication of type is set
"BASIC AUTH", for example:

<pre>
eureka.security.login=arch-demo:1234567890-1111-2222-3411111-000001
</pre>

> NOTE: This value is the same used to register the application or microservice in SERVICE-DISCOVERY (Eureka), by
> it doesn't change it in any way

That way, whenever SERVICE-ROUTER receives a request to route, it will first check if the service
is available through a REST call, sending the value of "eureka.security.login" in the request HEADER to
perform basic authentication: YXJjaC1kZW1vOjEyMzQ1Njc4OTAtMTExMS0yMjIyLTM0MTExMTEtMDAwMDAx.

# Sequence Diagram

The sequence diagram below shows a complete flow of requests made by the operator with the intention of consuming the
service called DEMO. We can see that the whole flow starts after the request-token request is started, which is
forwarded by the ROUTER to the AUTHORIZATOR service for token generation.

There are two requests: request-token and request-service made by the REQUESTER through any operator, but the
operator must be previously registered in the AUTHORIZATOR service. The ROUTER makes all redirects and calls
internal, in this case still without using a webserver for REVERSE-PROXY, and as soon as all operations are finished
a response is sent to the REQUESTER to be viewed by the operator.

> Sequence

![img.png](midias/Sequence.png)


# Authorization Process

A complete flow for a request-token type is illustrated below, where we can see what has already been
said earlier about the data that must be sent to authorize, authenticate and generate a token for an operator
any. See that we have the client data informed in the HEADER of the request with the BASIC-AUTH format, as well as the
operator credentials, which in this case is a user named OAUTH2DEMO_USER, also note that the type
grant_type that the AUTHORIZATOR service accepts, in this case password.

The ROUTER service receives the request and forwards it to the AUTHORIZATOR service which, when completing the validation operations
generate the token and response to the ROUTER so that it is returned to the REQUESTER. From that point on, the REQUESTER must save
the token (access-token) and inform it in future requests.

** In this case there is no access control header identified as: Access-Token

> Request Token Flow

![img.png](midias/Request-Token.png)

The following flow called request-service inevitably depends on the previous flow, you need to generate the access-token
to inform him at this stage. See that in the flow there is a block illustrating a request of this type simulating a
real operation, where we can notice the existence of the token in the HEADER of the request. Still at this point we have another HEADER
Access-Code call which is used to obtain the CLIENT authorization STRING BASIC-AUTH, this process is done
internally by the ROUTER, as it is necessary to know who was authorized to perform an operation.

Continuing in this request-service process, we have the internal and automatic request called check-token activated
by the ROUTER whenever it receives a request of type request-service. This step of the operation takes place on the backend of the
environment, and when all goes well, the ROUTER service forwards the request-service request to its original destination.

Right after the authorization "test by fire", the request arrives at the DEMO service which makes a call to RULES, which
in turn validates if the Rules-Code and Service-Id are correct, and it is clear too many rules to consume this
service, which are specific and inherent to the environment where the services are running.

> Request Service Flow

![img.png](midias/Request-Service.png)

The previously generated token verification step is contained within the request-service request and already
was addressed earlier in this content. Therefore, it does not need many explanations about the scopes already mentioned,
however in the image below we can see a novelty in the AUTHORIZATOR service block, we see that the token generated in the
previous steps is being kept in the machine's memory, and this is how OAuth2 verifies the sent token
in the check-token request. Of course, this is an internal procedure for OAuth2 and it is not up to us to explain about the operations
made in this scope of the process as a whole.

> Check Token Flow

![img.png](midias/Check-Token.png)


# Secure Environment

1.057 / 5.000
Resultados de tradução
In the environment below we have an environment more restricted to external access, previously we only had an open structure
of microservices running independently, but with an exposure of its elements to external agents. with the proposal
infrastructure shown in the figure below, we have a web server to orchestrate the external requests of such
so that the entire service platform from the ROUTER to any service such as the DEMO are protected from access
individuals.

The request is made by the operator, which reaches its final objective, going through the same steps discussed in this
document, but now we have Nginx that works in reverse with the requests forwarding and translating the
requests into the secure environment.

See that there is an internal network limited by the 10.0.0.0/16 subnet where its members can communicate with each other
but they cannot be accessed from outside that network except through Nginx. Also note that it is possible to customize the input url
in Nginx to the ROUTER, for example:

- NGINX
<pre>
Request Token
http://localhost:33001/nginx/huntercodexs/arch-demo/service-authorizator/api/rest/oauth/v1/oauth/token
</pre>

- ROUTER
<pre>
Reverse Proxy
http://10.0.0.2:33400/huntercodexs/arch-demo/service-authorizator/api/rest/oauth/v1/oauth/token
</pre>

This allows hiding both the real endpoint of the microservices as well as the port on which it is running.

> Using Nginx Webserver

![img.png](midias/Secure-Environment.png)


# How to use

To use this project, either as an environment initiator, for testing, or for presentations of work
academic or school or for any other purpose in the field of software, follow the instructions below:

- Clone the project on a local machine:

<pre>
git clone https://github.com/huntercodexs/arch-demo.git
</pre>

See that a folder called arch-demo was created, in which the example projects, media and documents are contained, as well as
as the POSTMAN file for testing.

Inside the arch-demo/microservices folder we have the example services: SERVICE-DISCOVERY, SERVICE-ROUTER, SERVICE-RULES,
SERVICE-AUTHORIZATOR and SERVICE-DEMO. All of them are just to exemplify the environment that can be executed
immediately after loading the project into an IDEA (example: IntelliJ).

** We will still have to configure the project to run in a secure environment using docker containers

Below we can see the microservices registered in SERVICE-DISCOVERY (Eureka) which are available to be
accessor via ROUTE.

![img.png](midias/service-discovery-sample.png)

Another important point is the dedicated database for each service, with no links between them, which could
cause confusion since we're talking about microservices. The figure below shows an image of this scenario:

![img.png](midias/arch-demo-databases.png)

> SERVICE-DISCOVERY

This service is responsible for managing the other services in relation to state, address (IP), port and other
resources, data that will be informed to the ROUTER when necessary.

> SERVICE ROUTE

Service responsible for routing all requests made to the ARCH-DEMO environment, this service checks with the service
DISCOVERY where is the target service to forward the request, this before going through the authorization process.

> SERVICE-AUTHORIZATOR

Service responsible for managing OAuth2 tokens.

> SERVICE-RULES

In this service are the business rules of the environment, every micro service must be integrated with this service to
that the business rules are validated correctly.

> SERVICE-DEMO

Example service to look up addresses via Correios with any zip code


# TODO

<table>
<tr>
<th>#</th>
<th>Description</th><th>Status</th>
</tr>
<tr>
<td>1</td>
<td>
Create a complete e-commerce environment with anti-fraud security and several databases, use PHP to create the website,
Python to process files, Java (Spring Boot) for APIs, Javascript (Jshunter) to do the front end. Include
also modules in NodeJS and ReactJS, several databases.
</td>
<td>TODO</td>
</tr>
<tr>
<td>2</td>
<td>
Insert security into the SERVICE-DISCOVERY (Eureka) registration process.
</td>
<td style="color: #00FF00;">DONE</td>
</tr>
<tr>
<td>3</td>
<td>
Insert an ExceptionHanlder for error handling in the environment's microservices.
</td>
<td style="color: #00FF00;">DONE</td>
</tr>
<tr>
<td>4</td>
<td>
Check if it is possible to obtain the SERVICE-DISCOVERY login data from the database.
</td>
<td style="color: #FF0000">CANCELED</td>
</tr>
<tr>
<td>5</td>
<td>
Enable Zipkin and Prometheus.
</td>
<td>TODO</td>
</tr>
<tr>
<td>6</td>
<td>
Enable Nginx using Docker.
</td>
<td>TODO</td>
</tr>
<tr>
<td>7</td>
<td>
Enable Swagger in microservices.
</td>
<td style="color: #FFFF00;">WORK</td>
</tr>
<tr>
<td>8</td>
<td>
Enable Unit and Integration Tests.
</td>
<td style="color: #00FF00;">DONE</td>
</tr>
<tr>
<td>9</td>
<td>
Create messaging service using RabbitMQ.
</td>
<td>TODO</td>
</tr>
<tr>
<td>10</td>
<td>
Enable DOC GUARD API (Personal project), check if it is possible to generate a JAR to use as a dependency.
</td>
<td>TODO</td>
</tr>
<tr>
<td>11</td>
<td>
Enable PROGUARD plugin for code obfuscation.
</td>
<td>TODO</td>
</tr>
</table>
